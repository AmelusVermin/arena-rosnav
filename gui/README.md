# Drawing panel for designing scenarios easily

### Requirements
1. Install Ubuntu 18.04.
2. Install [Kivy](https://kivy.org/doc/stable/gettingstarted/installation.html#install-pip). <br />
`$ python -m pip install --upgrade pip setuptools virtualenv` <br />
`$ python -m virtualenv kivy_venv` <br />
`$ source $HOME/kivy_venv/bin/activate` <br />
`$ python -m pip install kivy[base] kivy_examples`
3. Clone the whole project.
4. (if needed) install/update Pillow <br />
`$ python3 -m pip install --upgrade Pillow`
5. (if needed) install xclip <br />
`$ sudo apt-get install xclip`
6. (optional) if you want to support the `SHIFT+TAB` behaviour to jump backwards from text field to another, change in the file `$HOME/kivy_venv/lib/python3.6/site-packages/kivy/uix/behaviors/focus.py` in function `keyboard_on_key_down()` `['shift']` to `{'shift'}`

### How to run
1. Upload an image of the map in the `input` folder inside of the root folder.
2. Activate the kivy environment. <br />
`$ source $HOME/kivy_venv/bin/activate`
3. Navigate inside the project root folder. <br />
`$ cd arena-rosnav/gui`
4. Execute the `paint.py` file. <br />
`$ python paint.py`
5. Generate a new scenario in the paint app. Look at the rules! When ready, the next script `parser.py` will automatically start. <br />
6. The generated json file will be saved under the name `new_scenario.json` in the `output` folder as well as in the folder `arena-rosnav/simulator_setup/scenerios/`, where all scenarios are stored.
7. Modify the `arena-rosnav/arena_bringup/launch/sublaunch/task_generator.launch` file, changing the name of the expected json file to `new_scenario.json`. <br />
8. In `arena-rosnav` run for example <br />
`$ roslaunch arena_bringup start_arena_flatland.launch local_planner:="teb" use_viz:="true" map_file:="map1" rviz_file:="nav2"`. <br />
The file `nav2.rviz` is different from `nav.rviz` only by two things - the map is horizontal and the first couple of obstacles are visible with the start of rviz. The program still works will all available rviz files, just the visualization will be slightly defferent. Please take a look also at the section `Legend for the already tested maps` below.

### Folder structure
1. The root folder consist of both executable files `paint.py` and `parser.py`, as well as the ReadMe file.
2. The folder `input` inside of the root folder should be filled by the user before starting the program with the image of the map, for which scenarios have to be designed. <br />
**Attention:** Do not forget to adjust the name of the new map in the `paint.py` file!
3. The folder `output` inside of the root folder will be empty at first, but after the file `paint.py` has been run, it will fill with data and images from the painting program, as well as with the subfolder `internal`. As the name says, the data and images from the subfolder will be used for internal use from the files `paint.py` and `parser.py`. The output will be stored in the folder `output` itself. It will contain the generated json file `(new_scenario.json)`, the relevant to the user data such as map resolution etc. `(user_data.txt)` and a screenshot from the generated scenario `(scenario.png)`.
4. The folder `examples` consists of the saved data after creating different scenarios with the gui. It consists of the `internal` folder, it the parser should be run again and of the json file as well as other usefull data for the user to directly use the scenario as it is.
5. The folder `media` consists of screenshots and videos for different test rounds to give the user the feeling how a scenario should look like and to prove that the program works correctly.

### Rules for using the paint program
1. The first thing to do is to set the number of obstacles, the resolution and the origin of the uploaded map.

2. From the dropdown button on the left should be chosed the obstacle type. If nothing has been selected, the default type 'circle' (red) will be used. After that obstacles in form of circles with different colors (types) could be placed with a mouse click on the map. To change the position of the current obstacle, the clicked mouse could be moved in all directions, but only on the map. To change the radius of the obstacle, while the mouse is still clicked, the '+' and '-' button from the keyboard could be used to make it bigger or smaller. To see the changes the mouse should be moved slightly to triger the event. In the center of the new obstacle will appear an index, with which the obstacle will be saved. Different types of obstacles are supported in the same scenario.

3. When ready with the obstacles, click on the first button on the bottom left. From this point on the map could be positioned again with a mouse click watchers. Here apply the same rules for drawing as the one for the obstacles. To assign the watchers to obstacles the dynamically generated by the number of obstacles table on the right should be filled. In the same table should be also given the velocity for each obstacle, its waypoints, as well as its motion. The legend of the table per line from left to right is: obstacle index (already given, look at the map) - obstacle velocity - watcher indices for this obstacle (to separate multiple watchers use comma without spaces in between -> example: '1,2') - waypoint indices for this obstacle (the same as the watcher indices) - motion for this obstacle (example 'yoyo'). Depending on the used obstacle types there could be even more parameters to set.

4. When ready with the watchers, click on the second button on the bottom. From now on with mouse click and drag could be drawn lines. This lines represents the trajectory of the obstacles. The start of each line will not be considered, since it always should be at the center of an obstacle. But the end of the line is important, since there will be the end point of the movement of the dynamic obstacle. To be able to draw multiple waypoints per obstacle and not to be restricted by the order, in which they should be drawn, the waypoint indices per obstacle should be also written in the scrollable area on the right.

5. When ready with the lines (waypoints), on the map could be clicked the start and position of the robot. It could be clicked only twice and the first click should be for the start position. The center of the visualized two circles will be then considered as the start and end position of the robot, so the radius doesn't matter. At this point is also your last chance to make any changes to the parameters on the right and left.

6. When ready with the robot positions and filling up the data, click on the last button on the bottom to confirm that the scenario is now ready. No changes could be further made. The information from the paint app will be saved in files in the `output` folder. The information saved is still rough, so another python script `parser.py` will be automatically started. It will generate a json file for the just drawn scenario. The script could be of cource also run separately after the scenario, if some changes should be made to the json file without changing the scenario, since all important information from the scenario is saved in the output folder.

7. For drawing on the map only the left mouse click should be used. The mouse wheel is disabled, still right click and wheel button could visualize figures. However, they will not be considered. Pay attention that they will be visualized with slightly different color and will not get an index. So remember only to use the left click of the mouse, to not make the map crowded.

8. To make the user experience easier, there is a 'return' button. While placing the obstacles, the watchers, the waypoints or the robot positions, you can click on the button and you can start from the beginning of the current section. For example if you are currenly placing the watchers and you make a mistake, you can click on 'return' and you can start over with placing the watchers, without deleting the obstacles. Once you move forward to the waypoints, the watchers can not be changed anymore - if there is still a mistake, the programm should be started from the beginning. Be careful with the 'return' button while placing the obstacles. Since there are multiple available obstacle types, once you change the type of the obstacle to another, the obstacles from the first type can not be deleted anymore. The 'return' button will give you the chance to start over only with the current obstacle type.

9. From one text field to another can be jumped forwards pressing `TAB` and backwards pressing `SHIFT+TAB`. The scrollable area will also automatically scroll, so that the currently focused text field is visible. This makes the setup of parameters easier and faster.

### Legend for the already tested maps
1. map_small.png in paint.py -> resolution: 0.05; origin:(-6.0, -6.0) in the paint program -> ros launch with map_file:="map1"
2. map.png in paint.py -> resolution: 0.050000; origin: (-16.600000, -6.650000) in the paint program -> ros launch with map_file:="map0"

### Overview for working on different operation systems
#### (only for running this scenario gui, not the whole project!)

1. Ubuntu <br />
`$ source kivy_venv/bin/activate` <br />
`$ cd arena-rosnav/gui/` <br />
`$ python paint.py` <br />
`$ python parser.py` <br />

2. Windows from git bash <br />
`$ source kivy_venv/Scripts/activate` <br />
`$ cd Desktop/VIS_Windows/arena-rosnav/gui` <br />
`$ python paint.py` (move the black window a little bit to the bottom and back to make everything show) <br />
`$ python parser.py` (if everything is correct, the data will corectly show up, but if something is wrong, the program will terminate as it should do, but without showing the corresponding messages) <br />

3. Windows from cmd <br />
`$ kivy_venv\Scripts\activate` <br />
`$ cd Desktop\VIS_Windows\arena-rosnav\gui` <br />
`$ python paint.py` (move the black window a little bit to the bottom and back to make everything show) <br />
`$ python parser.py` <br />

4. Windows with WSL2 + Console <br />
It is not working. It can not deal with showing up a window.

5. Windows with WSL2 + GUI <br />
`$ source kivy_venv/bin/activate` <br />
`$ cd arena-rosnav/gui/` <br />
`$ python paint.py` <br />
`$ python parser.py` <br /><br />
**Attention:** Depending on the Python version that you are using, you may have to run the operations above with `python3` insteed of `python`!

### Tips and brief explanations for future developers how to modify/extend the program

1. To add additional obstacle type or to remove already existing one from the dropdown button search in `paint.py` for `dropdown_obstacle_type`. From there delete a button or create a new one and bind it to the dropdown button. A new button will need a callback function, where a new color for its visualization should be defined. A pair of obstacle type and its RGB color should be also added to the global array `obstacle_type`. In addition to the color change, also the obstacle type name could be written above the obstacle. If you think that this makes the map too crawded, you can only make a test run, where you put on the map an obstacle from each type with the name above it and save this as an image to show the user all obstacle color-types pairs and then comment out the names. This happens in the function `on_touch_up()` inside of the obstacle widget `MyPaintWidgetCircleObstacle`.

2. If new widgets for drawing additional behavior on the map should be included, the following things should be considered. <br />
    * After each step, after adding every new drawing widget, all drawings on the map until this point are saved as an image. Then the new widget is added, as well as the curent situation, but as an image. This is needed, since all drawing widgets are controlled from the mouse (and some of them also fro the keyboard) and once the new widget overtakes this power from the previous one, everything drawn from the previous widget gets deleted. So saving the curent status as an image avoids data los, but also prevents from controlling activity in the past. That is also why the return button has a limited power.

    * Since everything at some point is saved as an image, the data from each drawing widget should be saved to a txt file before losing the data - so while the user is working with the program and not at the end. Those files are not only used later on for `parser.py`, but also intern in `paint.py`. When for example the number of obstacles is needed, the lines in `output/obstacle.txt` are calculated etc.

    * Another possible issue is visualizing the new widget at the right moment. When multiple widgets are added one after another, every new widget is going to be visualized on top of the previous one. That is why the map should be always added first etc. So if you design an new widget and add it, but do not see it, there is good chance that it is there, but under some other widgets, so check carefully.

    * The `output/internal` folder is already used to saved the temporary images, right before adding a new widget. Use further this strategy and check those images, so that you are sure that only the drawing widgets up until now are exported and later on imported again. If everything from the window is saved, buttons for example will not act ever again as buttons, since they will be just a part of an image.

3. To add or remove obstacle parameters you should pay attention to the following things. All parameters are visible after the obstacles are already drawn, so after the first button is clicked (see the callback function `button_callback()`). Since the area with the parameters is dynamically generated, based on the number of obstacles given, a list is used for each obstacle parameter (for example `textinput_desire_force_factor[]`). These lists are generated in the main function `parent_widget()` and passed all trought the function `set_obstacle_params()`, which generates the scrollable area for the parameters. This is the function that you need to extend. First you need to generate a label for the new parameter, then in the loop to generate a text input for each obstacle (do not forget to bind the new text input to the `on_focus()` function, so that it is always visible when focused) and last, but not least to adjust the number of colums of the layout. Furthermore you have to decide if this new parameter should be always visible or only under some condition. The area is made scrollable to both up-down and left-right directions, so adding more parameters or deleting some in the future should not mess up with the overall layout. When a new parameter is added, its data should also be saved. Saving the data from the scrollable area happens after the last button is pushed (see its callback function `button4_callback()`). There the data from the new parameter should be saved to for example `data.txt`, from where it should be read in `parser.py` and later on written in the right form in the json file.

4. For now the window is made unresizable. It is not hard to make it resizable, but it is tricky to make the size of each widget to resize proparly and at the right moment. This is very important for the scale calculations, which are made to be able to scale the size of the original image of the map to the imported one. If for example the width of the original image is bigger then the space provided for importing it, it will altomatically scale, so the new size should be found manually. All of this is taken care of for an unresizable window, but pay attention to this, when developing a resizable window. Some initial steps are already done in the code.

5. The user is restricted to draw only on the map. This is done with restricting the mouse and keyboard events only inside the borders of the calculated new size of the imported map. This is important, since otherwise obstacle etc. will be drawn, when a button is clicked and the text areas will not be usable. Since the mouse has a moving behavior, it is important only only to check where the mouse starts its moving, but its position during all its motion. If after your implementation, an error has occured, after you clicked somewhere on the map, the most possible reason is that the boundaries for the mouse event have not been taken into consideration.

6. For future development it could be considered to improve the behavior of the return button, to be able to return only one mouse click and not a whole session. A possible way could be to save a temporary image of all drawing widgets after each click. This could allow returning one click, but still only one.

7. It is also important, to restrict untill which point of the designing the scenario which features should be already given by the user and must not be changed afterwards etc., so to control the flow of the prozess. You can do this for example by enabling/disabling some widgets after a certain event is triggered.

8. For setting the motion (yoyo, circle etc.) for each obstacle for now are used dynamically generated text fields. Since new types of motions could be added in the future, this is the more simpler way to add them by just writing the new type inside of the field. Of cource to make it more secure, it should be checked, if what is written inside is a valid motion type or not. This is made inside of the script `parser.py` before creating the json file. In an array are saved valid motion types and the given types are checked if they are on the list. So to add new types, this array should be extended, otherwise the program will terminate. Another way to take care of the motion of each obstacle is by dynamically creating dropdown buttons. Up until now was no way found to do this dynamically without knowing how much obstacles are there in the beginning. The problem is that the names of all dropdown buttons and buttons inside should be different and fixed for the whole program, because otherwise the binding will not work. A temporary solution was implemented - the number of obstacles was restricted up until 20 and all posibilities from 0 to 20 obstacles were hard coded. This solution is still in the code (commented out), if in the future this method with dropdown buttons is tried again. So for now we stick with the text fields.
