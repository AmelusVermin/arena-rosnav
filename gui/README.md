# Drawing panel for designing scenarios easily

### Requirements
1. Install Ubuntu 18.04.
2. Install [Kivy](https://kivy.org/doc/stable/gettingstarted/installation.html#install-pip). <br />
`$ python -m pip install --upgrade pip setuptools virtualenv` <br />
`$ python -m virtualenv kivy_venv` <br />
`$ source $HOME/kivy_venv/bin/activate` <br />
`$ python -m pip install kivy[base] kivy_examples`
3. Clone the whole project.
4. (if needed) install/update Pillow <br />
`$ python3 -m pip install --upgrade Pillow`
5. (if needed) install xclip <br />
`$ sudo apt-get install xclip`

### How to run
1. Upload an image of the map in the `input` folder inside of the root folder.
2. Activate the kivy environment. <br />
`$ source $HOME/kivy_venv/bin/activate`
3. Navigate inside the project root folder. <br />
`$ cd arena-rosnav/gui`
4. Execute the `paint.py` file. <br />
`$ python paint.py`
5. Generate a new scenario in the paint app. Look at the rules!
6. Execute the `parser.py` file. <br />
`$ python parser.py`
7. The generated json file will be saved under the name `new_scenario.json` in the `output` folder as well as in the folder `arena-rosnav/simulator_setup/scenerios/`, where all scenarios are stored.
8. Modify the `arena-rosnav/arena_bringup/launch/sublaunch/task_generator.launch` file, changing the name of the expected json file to `new_scenario.json`. <br />
9. In `arena-rosnav` run for example <br />
`$ roslaunch arena_bringup start_arena_flatland.launch local_planner:="teb" use_viz:="true" map_file:="map1" rviz_file:="nav2"`. <br />
The file `nav2.rviz` is different from `nav.rviz` only by two things - the map is horizontal and the first couple of obstacles are visible with the start of rviz. The program still works will all available rviz files, just the visualization will be slightly defferent. Please take a look also at the section `Legend for the already tested maps` below.

### Folder structure
1. The root folder consist of both executable files `paint.py` and `parser.py`, as well as the ReadMe file.
2. The folder `input` inside of the root folder should be filled by the user before starting the program with the image of the map, for which scenarios have to be designed. <br />
**Attention:** Do not forget to adjust the name of the new map in the `paint.py` file!
3. The folder `output` inside of the root folder will be empty at first, but after the file `paint.py` has been run, it will fill with data and images from the painting program, as well as with the subfolder `internal`. As the name says, the data and images from the subfolder will be used for internal use from the files `paint.py` and `parser.py`. The output will be stored in the folder `output` itself. It will contain the generated json file `(new_scenario.json)`, the relevant to the user data such as map resolution etc. `(user_data.txt)` and a screenshot from the generated scenario `(scenario.png)`.

### Rules for using the paint program
1. The first thing to do is to set the number of obstacles, the resolution and the origin of the uploaded map.

2. From the dropdown button on the left should be chosed the obstacle type. If nothing has been selected, the default type 'circle' (red) will be used. After that obstacles in form of circles with different colors (types) could be placed with a mouse click on the map. To change the radius of the obstacle, the clicked mouse could be moved left-right and the radius will accordingly get smaller-bigger. In the center of the new obstacle will appear an index, with which the obstacle will be saved. Different types of obstacles are supported in the same scenario.

3. When ready with the obstacles, click on the first button on the bottom left. From this point on the map could be positioned again with a mouse click watchers. To assign the watchers to obstacles the dynamically generated by the number of obstacles table on the right should be filled. In the same table should be also given the velocity for each obstacle, as well as its motion. The legend of the table per line from left to right is: obstacle index (look at the map) - obstacle velocity - watcher indices for this obstacle (to separate multiple watchers use comma without spaces in between -> example: '1,2') - motion for this obstacle (example 'yoyo').

4. When ready with the watchers and the information, click on the second button on the bottom. From now on with mouse click and drag could be drawn lines. This lines represents the trajectory of the obstacles. The start of each line will not be considered, since it always should be at the center of an obstacle. But the end of the line is important, since there will be the end point of the movement of the dynamic obstacle. Because there is now way to connect a line to its obstacle, it is important to draw the lines in the same order as the obstacle - so to start with drawing the motion for obstacle 0, then for obstacle 1 and so on.

5. When ready with the lines (waypoints), on the map could be clicked the start and position of the robot. It could be clicked only twice and the first click should be for the start position. The center of the visualized two circles will be then considered as the start and end position of the robot, so the radius doesn't matter.

6. When ready with the robot positions, click on the last button on the bottom to confirm that the scenario is now ready. No changes could be further made. The information from the paint app will be saved in files in the `output` folder. The information saved is still rough, so another python script `parser.py` should run after that to become the json file for the just generated scenario.

7. To make the user experience easier, there is a 'return' button. While placing the obstacles, the watchers, the waypoints or the robot positions, you can click on the button and you can start from the beginning of the current section. For example if you are currenly placing the watchers and you make a mistake, you can click on 'return' and you can start over with placing the watchers, without deleting the obstacles. Once you move forward to the waypoints, the watchers can not be changed anymore - if there is still a mistake, the programm should be started from the beginning. Be careful with the 'return' button while placing the obstacles. Since there are multiple available obstacle types, once you change the type of the obstacle to another, the obstacles from the first type can not be deleted anymore. The 'return' button will give you the chance to start over only with the current obstacle type.

### Legend for the already tested maps
1. map_small.png in paint.py -> resolution: 0.05; origin:(-6.0, -6.0) in the paint program -> ros launch with map_file:="map1"
2. map.png in paint.py -> resolution: 0.050000; origin: (-16.600000, -6.650000) in the paint program -> ros launch with map_file:="map0"

### Overview for working on different operation systems
#### (only for running this scenario gui, not the whole project!)

1. Ubuntu <br />
`$ source kivy_venv/bin/activate` <br />
`$ cd arena-rosnav/gui/` <br />
`$ python paint.py` <br />
`$ python parser.py` <br />

2. Windows from git bash <br />
`$ source kivy_venv/Scripts/activate` <br />
`$ cd Desktop/VIS_Windows/arena-rosnav/gui` <br />
`$ python paint.py` (move the black window a little bit to the bottom and back to make everything show) <br />
`$ python parser.py` (if everything is correct, the data will corectly show up, but if something is wrong, the program will terminate as it should do, but without showing the corresponding messages) <br />

3. Windows from cmd <br />
`$ kivy_venv\Scripts\activate` <br />
`$ cd Desktop\VIS_Windows\arena-rosnav\gui` <br />
`$ python paint.py` (move the black window a little bit to the bottom and back to make everything show) <br />
`$ python parser.py` <br />

4. Windows with WSL2 + Console <br />
It is not working. It can not deal with showing up a window.

5. Windows with WSL2 + GUI <br />
`$ source kivy_venv/bin/activate` <br />
`$ cd arena-rosnav/gui/` <br />
`$ python paint.py` <br />
`$ python parser.py` <br /><br />
**Attention:** Depending on the Python version that you are using, you may have to run the operations above with `python3` insteed of `python`!
